/*
 * Copyright (C) 2015 maignial
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package application;

import java.awt.Component;
import java.awt.event.KeyEvent;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFileChooser;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JViewport;

/**
 *
 * @author maignial
 */
public class TextEditor extends javax.swing.JFrame {

    /**
     * Creates new form TextEditor
     */
    public TextEditor() {
        initComponents();
        this.files = new ArrayList<>();
       
        String home = System.getenv("HOME");
        home += "/.cacheSim/cacheSim.conf";
        
        File f = new File(home);
        BufferedReader reader;
        String line;
        try {
            reader = new BufferedReader(new InputStreamReader(new FileInputStream(f)));

            while ((line = reader.readLine()) != null) {
                if (line.startsWith("CACHESIM_PATH=")) {
                    projectPath = line.split("=")[1];
                    break;
                }
            }
        } catch (FileNotFoundException ex) {
            Logger.getLogger(TextEditor.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            Logger.getLogger(TextEditor.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
        
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        fileOpener = new javax.swing.JFileChooser();
        messagesConsole = new javax.swing.JDialog();
        jPanel1 = new javax.swing.JPanel();
        jScrollPane2 = new javax.swing.JScrollPane();
        outputConsole = new javax.swing.JTextArea();
        filenameRequester = new javax.swing.JDialog();
        jTextField1 = new javax.swing.JTextField();
        jLabel1 = new javax.swing.JLabel();
        jButton1 = new javax.swing.JButton();
        closeableTabbedPane1 = new application.swing_utils.MyTabbedPane();
        jMenuBar1 = new javax.swing.JMenuBar();
        reloadMenuItem = new javax.swing.JMenu();
        jMenuItem2 = new javax.swing.JMenuItem();
        importFileMenuItem = new javax.swing.JMenuItem();
        jMenuItem1 = new javax.swing.JMenuItem();
        quitMenuItem = new javax.swing.JMenuItem();

        fileOpener.setCurrentDirectory(null);
        fileOpener.setDialogTitle("");
        fileOpener.setMultiSelectionEnabled(true);

        messagesConsole.setTitle("command output");
        messagesConsole.setMinimumSize(new java.awt.Dimension(400, 300));

        outputConsole.setEditable(false);
        outputConsole.setColumns(20);
        outputConsole.setLineWrap(true);
        outputConsole.setRows(5);
        jScrollPane2.setViewportView(outputConsole);

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 400, Short.MAX_VALUE)
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 300, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout messagesConsoleLayout = new javax.swing.GroupLayout(messagesConsole.getContentPane());
        messagesConsole.getContentPane().setLayout(messagesConsoleLayout);
        messagesConsoleLayout.setHorizontalGroup(
            messagesConsoleLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        messagesConsoleLayout.setVerticalGroup(
            messagesConsoleLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        filenameRequester.setMinimumSize(new java.awt.Dimension(459, 201));
        filenameRequester.setModalExclusionType(java.awt.Dialog.ModalExclusionType.APPLICATION_EXCLUDE);
        filenameRequester.setModalityType(java.awt.Dialog.ModalityType.TOOLKIT_MODAL);
        filenameRequester.setResizable(false);

        jTextField1.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                jTextField1KeyPressed(evt);
            }
        });

        jLabel1.setText("Tab name:");

        jButton1.setText("Ok");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout filenameRequesterLayout = new javax.swing.GroupLayout(filenameRequester.getContentPane());
        filenameRequester.getContentPane().setLayout(filenameRequesterLayout);
        filenameRequesterLayout.setHorizontalGroup(
            filenameRequesterLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, filenameRequesterLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, 367, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
            .addGroup(filenameRequesterLayout.createSequentialGroup()
                .addGap(218, 218, 218)
                .addComponent(jButton1)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        filenameRequesterLayout.setVerticalGroup(
            filenameRequesterLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(filenameRequesterLayout.createSequentialGroup()
                .addGap(68, 68, 68)
                .addGroup(filenameRequesterLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel1))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jButton1)
                .addContainerGap(69, Short.MAX_VALUE))
        );

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Text Editor");

        reloadMenuItem.setText("File");

        jMenuItem2.setText("Create new empty tab");
        jMenuItem2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem2ActionPerformed(evt);
            }
        });
        reloadMenuItem.add(jMenuItem2);

        importFileMenuItem.setText("Import file");
        importFileMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                importFileMenuItemActionPerformed(evt);
            }
        });
        reloadMenuItem.add(importFileMenuItem);

        jMenuItem1.setText("Reload files");
        jMenuItem1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem1ActionPerformed(evt);
            }
        });
        reloadMenuItem.add(jMenuItem1);

        quitMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_Q, java.awt.event.InputEvent.CTRL_MASK));
        quitMenuItem.setText("Quit");
        quitMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                quitMenuItemActionPerformed(evt);
            }
        });
        reloadMenuItem.add(quitMenuItem);

        jMenuBar1.add(reloadMenuItem);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(closeableTabbedPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 607, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(closeableTabbedPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 343, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void importFileMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_importFileMenuItemActionPerformed
        this.importFile();
    }//GEN-LAST:event_importFileMenuItemActionPerformed

    private void jMenuItem1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem1ActionPerformed
        this.reloadFiles();
    }//GEN-LAST:event_jMenuItem1ActionPerformed

    private void jMenuItem2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem2ActionPerformed
        this.filenameRequester.setVisible(true);
        JScrollPane scroller = new JScrollPane();
        JTextArea text = new JTextArea("");
        scroller.setViewportView(text);
        this.closeableTabbedPane1.addTab(jTextField1.getText(), scroller);
    }//GEN-LAST:event_jMenuItem2ActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        this.filenameRequester.setVisible(false);
    }//GEN-LAST:event_jButton1ActionPerformed

    private void jTextField1KeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextField1KeyPressed
        if (evt.getKeyCode() == KeyEvent.VK_ENTER)
            this.filenameRequester.setVisible(false);
    }//GEN-LAST:event_jTextField1KeyPressed

    private void quitMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_quitMenuItemActionPerformed
        this.dispose();
    }//GEN-LAST:event_quitMenuItemActionPerformed

    /**
     * Crée un nouvel onglet avec le contenu du fichier dans la fenêtre.
     */
    public void importFile() {
        JTextArea text;
        String tabTitle;
        File[] f;
        
        if (this.fileOpener.showOpenDialog(this) != JFileChooser.APPROVE_OPTION)
            return;

        f = this.fileOpener.getSelectedFiles();
        for (int i=0 ; i<f.length ; ++i) {
            this.files.add(f[i]);

            tabTitle = f[i].getName();
            if (f[i].getName().endsWith(".elf")) {
                text = disamElf(f[i]);
                
                tabTitle = tabTitle + " (disassembled)";
            } else {
                text = readFile(f[i]);
            }
            
            if (text != null) {
                JScrollPane scroller = new JScrollPane();
                scroller.setViewportView(text);
                this.closeableTabbedPane1.add(tabTitle, scroller);
            }
        }
    }
    
    /**
     * Désassemble un fichier elf et renvoie une JTextArea contenant le code désassemblé.
     * @param input le fichier à désassembler
     * @return Le code assembleur.
     */
    public JTextArea disamElf(File input) {
        JTextArea sourceCode = new JTextArea();
        
        final String command = projectPath +
                "/arm_tools/bin/arm-none-eabi-objdump -d -S " +
                input.getAbsolutePath();
        final int disamStatus = execCommand(command, sourceCode);
        
        if (disamStatus != 0) {
            outputConsole.setText(sourceCode.getText());
            this.messagesConsole.setVisible(true);
            return null;
        } else {
            return sourceCode;
        }
    }

    /**
     * Lis un fichier et écrit son contenu dans une JTextArea.
     * @param input le fichier lu
     * @return un JTextArea conteant le fichier sous forme ascii
     */
    public JTextArea readFile(File input) {
        JTextArea text = new JTextArea();

        BufferedReader reader;
        char[] buffer = new char[1024];
        try {
            reader = new BufferedReader(new InputStreamReader(new FileInputStream(input)));

            int n;
            while ((n = reader.read(buffer)) != -1) {
                text.append(new String(buffer, 0, n));
            }
        } catch (FileNotFoundException ex) {
            Logger.getLogger(TextEditor.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            Logger.getLogger(TextEditor.class.getName()).log(Level.SEVERE, null, ex);
        }

        return text;
    }

    /**
     * Recharge les fichiers déjà ouverts //TODO debug
     */
    public void reloadFiles() {
        List<String> oldFiles;
        List<String> importedFiles = new ArrayList<>();

        try {
            oldFiles = saveTabsToFiles(projectPath + "/workspace/");
        } catch (IOException ex) {
            Logger.getLogger(TextEditor.class.getName()).log(Level.SEVERE, null, ex);
            return;
        }
        
        closeableTabbedPane1.removeAll();
        
        JTextArea text;
        for (File f : files) {
            text = readFile(f);
            this.closeableTabbedPane1.add(f.getName(), text);
            importedFiles.add(f.getName());
        }
        
        String[] split;
        for (String s : oldFiles) {
            split = s.split("/");
            s = split[split.length];
            if (! importedFiles.contains(s)) {
                text = readFile(new File (projectPath + "/workspace/" + s));
                this.closeableTabbedPane1.add(s, text);
            }
        }
    }

    /**
     * Permet d'obtenir le nom du fichier executable (ouvert ou compilé)
     * @return le nom absolu du fichier executable
     */
    public String getExecPath (){
        String execPath = null;
        
        for (File f : files) {
            if (f.getName().endsWith(".elf")) {
                if (execPath == null)
                    execPath = f.getAbsolutePath();
                else {
                    this.outputConsole.setText(
                            "Error, there is several .elf opened."
                            + "You must have at most one .elf opened.");
                    this.messagesConsole.setVisible(true);
                    return null;
                }
            }
        }
        
        if (execPath == null)
            execPath = buildOpenedFiles();
        
        return execPath;
    }

    /**
     * Compile les fichiers ouverts et produit un executable.
     * @return le chemin du fichier executable, null en cas d'erreur.
     */
    public String buildOpenedFiles() {
        int type;
        String workspace;
        String command;
        String inputFile;
        Iterator<String> it;
        List<String> filenames;
        List<String> objFiles;
        JTextArea output = this.outputConsole;

        output.setText("");
        this.messagesConsole.setVisible(true);

        /* vérification des types de fichiers */
        type = CheckFilesType();
        if (type == mixedSources) {
            output.append("Warning: differents kind of source file are opend.\n"
                    + "Build aborted.");
            return null;
        }
        if (type == noKnownTypes) {
            output.append("There is no source file opend");
            return null;
        }
        

        /* Sauvegarde des onglets sous forme de fichier et récupération de leurs noms */
        workspace = projectPath + "/workspace";

        try {
            filenames = saveTabsToFiles(workspace);
        } catch (IOException ex) {
            output.append(ex.getMessage());
            return null;
        }

        /* génération de la commande de build */
        objFiles = new ArrayList<>();
        switch (type) {
            case cSource:
                command = projectPath +
                        "/arm_tools/bin/arm-none-eabi-gcc -std=c99 " +
                        "-B " + workspace + // include des .h ouverts
                        " -c " ;
                it = filenames.iterator();

                while (it.hasNext()) {
                    inputFile = it.next();
                    /* on ignore les headers */
                    if (inputFile.endsWith(".c")) {
                        if(0 != execCommand(command + inputFile +
                                " -o " +
                                inputFile.substring(0, inputFile.length() - 2) +
                                ".o", output))
                            return null;
                        
                        objFiles.add(inputFile.substring(0, inputFile.length() - 2)
                                + ".o");
                    }
                }
                break;
            case assemblySource:
                command = projectPath + "/arm_tools/bin/arm-none-eabi-as ";
                it = filenames.iterator();
                while (it.hasNext()) {
                    inputFile = it.next() + " ";
                    if(inputFile.endsWith(".S"))
                        command += inputFile + " ";
                }
                objFiles.add("obj.o");
                command += "-o" + workspace + "obj.o";
                if(0 != execCommand(command, output))
                    return null;
                break;
            default:
                output.append("Internal error: unknow type of source.");
                return null;
        }        

        /* édition de liens */
        command = projectPath + "/arm_tools/bin/arm-none-eabi-ld ";
        it = objFiles.iterator();
        while (it.hasNext())
            command += it.next() + " ";
        command += "-o " + workspace + "/exec.elf";
        
        if(0 != execCommand(command, output))
            return null;
        
        return workspace + "/exec.elf";
    }
    
    /**
     * Execute une commande système
     * @param command la commande à executer
     * @param output la "console" de sortie
     * @return le code de retour du processus executé.
     */
    public int execCommand(String command, JTextArea output) {
        Runtime runtime;
        InputStream stdOut;
        InputStream stdErr;
        final Process process;
        byte[] buffer = new byte[1024];
        int n;
        
        runtime = Runtime.getRuntime();
        try {
            process = runtime.exec(command);
            process.waitFor();
            if (output != null) {
                output.append("Exec: " + command + "\n\n");
                stdOut = process.getInputStream();
                stdErr = process.getErrorStream();

                /* lecture de la sortie standard */
                if (stdOut.available() != 0)
                    output.append("STDOUT:\n");
                while ((n = stdOut.read(buffer)) != -1) {
                    output.append(new String(buffer, 0, n));
                }

                /* lecture de la sortie standard des erreurs*/
                if (stdErr.available() != 0)
                    output.append("\nSTDERR:\n");
                while ((n = stdErr.read(buffer)) != -1) {
                    output.append(new String(buffer, 0, n));
                }
            }

            return process.exitValue();
        } catch (IOException | InterruptedException ex) {
            if (output != null) {
                output.append(ex.getMessage());
            }
            return -1;
        }
    }

    /**
     * Sauvegarde le texte des onglets dans des fichiers Attention le répertoire
     * de sauvegarde seras supprimé.
     *
     * @param path le chemin du répertoire ou créer les fichiers
     * @return une liste de chemin de fichiers (les fichiers créés).
     */
    private List<String> saveTabsToFiles(final String path) throws IOException {
        ArrayList<String> filenames = new ArrayList<>();

        /* initialisation du répertoire de travail */
        File workspace = new File(path);
        if (workspace.exists() && workspace.isFile()) {
            workspace.delete();
        } else if (workspace.exists()) {
            rmDir(workspace);
        }
        if (!workspace.exists()) {
            if (!workspace.mkdir()) {
                return null;
            }
        }

        /* parcours des onglets  */
        final int fileCount = this.closeableTabbedPane1.getTabCount();
        Component tab;
        JTextArea tabText;
        File tempFile;
        String name;
        PrintWriter writer;
        for (int i = 0; i < fileCount; ++i) {
            tab = this.closeableTabbedPane1.getComponentAt(i);

            /* on vas chercher une éventuelle JTextArea dans l'onglet */
            tabText = null;
            if (tab instanceof JScrollPane) {
                tab = ((JScrollPane) tab).getComponent(0);
                if (tab instanceof JViewport) {
                    tab = ((JViewport) tab).getComponent(0);
                    if (tab instanceof JTextArea) {
                        tabText = (JTextArea) tab;
                    }
                }
            }

            /* Enregistrement du texte dans un fichier */
            if (tabText != null) {
                name = path + "/" + this.closeableTabbedPane1.getTitleAt(i);
                tempFile = new File(name);
                name = tempFile.getCanonicalPath();
                filenames.add(name);

                tempFile.createNewFile();

                writer = new PrintWriter(new BufferedWriter(
                        new FileWriter(tempFile)));
                writer.print(tabText.getText());
                writer.close();
            }
        }

        return filenames;
    }

    /**
     * Permet de déterminer le type des fichiers et si ceux-ci sont d'un type
     * attendu (que des .h.c ou que des .S).
     *
     * @return le type de fichier.
     */
    private int CheckFilesType() {
        String name;
        int type = noKnownTypes;

        for (File f : files) {
            name = f.getName();
            if (name.endsWith(".c") || name.endsWith(".h")) {
                if (type == assemblySource) {
                    return mixedSources;
                } else if (type == noKnownTypes) {
                    type = cSource;
                }
            } else if (name.endsWith(".S")) {
                if (type == cSource) {
                    return mixedSources;
                } else if (type == noKnownTypes) {
                    type = assemblySource;
                }
            }
        }

        return type;
    }

    /**
     * Permet de supprimer un dossier et toute l'arborescence sous-jacente.
     *
     * @return vrais si le dossier a pu être supprimé, faux sinon.
     */
    private boolean rmDir(File dir) {
        boolean result;
        if (dir.isDirectory()) {
            for (File f : dir.listFiles()) {
                result = (f.isDirectory()) ? rmDir(f) : f.delete();
                if (!result) {
                    return false;
                }
            }
        } else {
            return false;
        }
        return true;
    }

    private final List<File> files;
    public static final int cSource = 1;
    public static final int assemblySource = 2;
    public static final int noKnownTypes = 0;
    public static final int mixedSources = -1;
    public String projectPath;
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private application.swing_utils.MyTabbedPane closeableTabbedPane1;
    private javax.swing.JFileChooser fileOpener;
    private javax.swing.JDialog filenameRequester;
    private javax.swing.JMenuItem importFileMenuItem;
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JMenuItem jMenuItem1;
    private javax.swing.JMenuItem jMenuItem2;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JTextField jTextField1;
    private javax.swing.JDialog messagesConsole;
    private javax.swing.JTextArea outputConsole;
    private javax.swing.JMenuItem quitMenuItem;
    private javax.swing.JMenu reloadMenuItem;
    // End of variables declaration//GEN-END:variables
}
